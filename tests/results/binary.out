CREATE EXTENSION clickhouse_fdw;
SET datestyle = 'ISO';
CREATE SERVER testserver1 FOREIGN DATA WRAPPER clickhouse_fdw OPTIONS(dbname 'regression');
CREATE SERVER loopback FOREIGN DATA WRAPPER clickhouse_fdw OPTIONS(dbname 'regression', driver 'binary');
CREATE SERVER loopback2 FOREIGN DATA WRAPPER clickhouse_fdw OPTIONS(dbname 'regression');
CREATE ROLE user1 SUPERUSER;
SET ROLE user1;
CREATE USER MAPPING FOR public SERVER testserver1 OPTIONS (user 'value', password 'value');
CREATE USER MAPPING FOR user1 SERVER loopback;
CREATE USER MAPPING FOR user1 SERVER loopback2;
SELECT clickhousedb_raw_query('DROP DATABASE IF EXISTS regression');
 clickhousedb_raw_query 
------------------------
 
(1 row)

SELECT clickhousedb_raw_query('CREATE DATABASE regression');
 clickhousedb_raw_query 
------------------------
 
(1 row)

SELECT clickhousedb_raw_query('CREATE TABLE regression.t1
	(c1 Int, c2 Int, c3 String, c4 Date, c5 Date, c6 String, c7 String, c8 String)
	ENGINE = MergeTree PARTITION BY c4 ORDER BY (c1);
');
 clickhousedb_raw_query 
------------------------
 
(1 row)

SELECT clickhousedb_raw_query('CREATE TABLE regression.t2 (c1 Int, c2 String)
	ENGINE = MergeTree PARTITION BY c1 % 10000 ORDER BY (c1);');
 clickhousedb_raw_query 
------------------------
 
(1 row)

SELECT clickhousedb_raw_query('CREATE TABLE regression.t3 (c1 Int, c2 Int, c3 String)
	ENGINE = MergeTree PARTITION BY c1 % 10000 ORDER BY (c1);');
 clickhousedb_raw_query 
------------------------
 
(1 row)

SELECT clickhousedb_raw_query('CREATE TABLE regression.t4 (c1 Int, c2 Int, c3 String)
	ENGINE = MergeTree PARTITION BY c1 % 10000 ORDER BY (c1);');
 clickhousedb_raw_query 
------------------------
 
(1 row)

SELECT clickhousedb_raw_query('
	CREATE TABLE regression.tcopy
		(c1 Int32, c2 Int64, c3 Date, c4 DateTime, c5 DateTime, c6 String)
	ENGINE = MergeTree
	PARTITION BY c3
	ORDER BY (c1, c2, c3);
');
 clickhousedb_raw_query 
------------------------
 
(1 row)

CREATE FOREIGN TABLE ft1 (
	c0 int,
	c1 int NOT NULL,
	c2 int NOT NULL,
	c3 text,
	c4 date,
	c5 date,
	c6 varchar(10),
	c7 char(10) default 'ft1',
	c8 text
) SERVER loopback OPTIONS (table_name 't1');
ALTER FOREIGN TABLE ft1 DROP COLUMN c0;
CREATE FOREIGN TABLE ft2 (
	c1 int NOT NULL,
	c2 text NOT NULL
) SERVER loopback OPTIONS (table_name 't2');
CREATE FOREIGN TABLE ft3 (
	c1 int NOT NULL,
	c2 int NOT NULL,
	c3 text
) SERVER loopback OPTIONS (table_name 't3');
CREATE FOREIGN TABLE ft4 (
	c1 int NOT NULL,
	c2 int NOT NULL,
	c3 text
) SERVER loopback OPTIONS (table_name 't4');
CREATE FOREIGN TABLE ft5 (
	c1 int NOT NULL,
	c2 int NOT NULL,
	c3 text
) SERVER loopback OPTIONS (table_name 't4');
CREATE FOREIGN TABLE ft6 (
	c1 int NOT NULL,
	c2 int NOT NULL,
	c3 text
) SERVER loopback2 OPTIONS (table_name 't4');
CREATE FOREIGN TABLE ftcopy (
	c1 int,
	c2 int8,
	c3 date,
	c4 timestamp without time zone,
	c5 time,
	c6 text
) SERVER loopback OPTIONS (table_name 'tcopy');
INSERT INTO ft1
	SELECT id,
	       id % 10,
	       to_char(id, 'FM00000'),
	       '1990-01-01',
	       '1990-01-01',
	       id % 10,
	       id % 10,
	       'foo'
	FROM generate_series(1, 110) id;
ERROR:  clickhouse_fdw: insertion is not implemented for binary protocol yet
INSERT INTO ft2
	SELECT id,
	       'AAA' || to_char(id, 'FM000')
	FROM generate_series(1, 100) id;
ERROR:  clickhouse_fdw: insertion is not implemented for binary protocol yet
INSERT INTO ft3
	SELECT id,
	       id + 1,
	       'AAA' || to_char(id, 'FM000')
	FROM generate_series(1, 100) id;
ERROR:  clickhouse_fdw: insertion is not implemented for binary protocol yet
INSERT INTO ft4
	SELECT id,
	       id + 1,
	       'AAA' || to_char(id, 'FM000')
	FROM generate_series(1, 100) id;
ERROR:  clickhouse_fdw: insertion is not implemented for binary protocol yet
COPY ftcopy FROM stdin;
ERROR:  clickhouse_fdw: insertion is not implemented for binary protocol yet
INSERT INTO ftcopy VALUES
	(3, 4, '1990-03-03', '1990-03-03 12:02:02', '12:02:02', 'val3'),
	(4, 5, '1991-04-04', '1990-04-04 12:04:04', '12:02:04', 'val4');
ERROR:  clickhouse_fdw: insertion is not implemented for binary protocol yet
EXPLAIN (VERBOSE) SELECT * FROM ftcopy ORDER BY c1;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Foreign Scan on public.ftcopy  (cost=1.00..-1.00 rows=2 width=64)
   Output: c1, c2, c3, c4, c5, c6
   Remote SQL: SELECT c1, c2, c3, c4, c5, c6 FROM regression.tcopy ORDER BY c1 ASC
(3 rows)

SELECT * FROM ftcopy ORDER BY c1;
 c1 | c2 | c3 | c4 | c5 | c6 
----+----+----+----+----+----
(0 rows)

ALTER USER MAPPING FOR public SERVER testserver1
	OPTIONS (DROP user, DROP password);
\det+
                      List of foreign tables
 Schema | Table  |  Server   |     FDW options      | Description 
--------+--------+-----------+----------------------+-------------
 public | ft1    | loopback  | (table_name 't1')    | 
 public | ft2    | loopback  | (table_name 't2')    | 
 public | ft3    | loopback  | (table_name 't3')    | 
 public | ft4    | loopback  | (table_name 't4')    | 
 public | ft5    | loopback  | (table_name 't4')    | 
 public | ft6    | loopback2 | (table_name 't4')    | 
 public | ftcopy | loopback  | (table_name 'tcopy') | 
(7 rows)

\set VERBOSITY terse
SELECT c3, c4 FROM ft1 ORDER BY c3, c1 LIMIT 1;  -- should work
 c3 | c4 
----+----
(0 rows)

ALTER SERVER loopback OPTIONS (SET dbname 'no such database');
SELECT c3, c4 FROM ft1 ORDER BY c3, c1 LIMIT 1;  -- should fail
ERROR:  clickhouse_fdw: connection error: DB::Exception: Database no such database doesn't exist
ALTER USER MAPPING FOR user1 SERVER loopback OPTIONS (ADD user 'no such user');
SELECT c3, c4 FROM ft1 ORDER BY c3, c1 LIMIT 1;  -- should fail
ERROR:  clickhouse_fdw: connection error: DB::Exception: Unknown user no such user
ALTER SERVER loopback OPTIONS (SET dbname 'regression');
ALTER USER MAPPING FOR user1 SERVER loopback OPTIONS (DROP user);
SELECT c3, c4 FROM ft1 ORDER BY c3, c1 LIMIT 1;  -- should work again
 c3 | c4 
----+----
(0 rows)

\set VERBOSITY default
ANALYZE ft1;
EXPLAIN (COSTS OFF) SELECT * FROM ft1 ORDER BY c3, c1 OFFSET 100 LIMIT 10;
        QUERY PLAN         
---------------------------
 Limit
   ->  Foreign Scan on ft1
(2 rows)

SELECT * FROM ft1 ORDER BY c3, c1 OFFSET 100 LIMIT 10;
 c1 | c2 | c3 | c4 | c5 | c6 | c7 | c8 
----+----+----+----+----+----+----+----
(0 rows)

EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 ORDER BY t1.c3, t1.c1, t1.tableoid OFFSET 100 LIMIT 10;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Limit
   Output: c1, c2, c3, c4, c5, c6, c7, c8, tableoid
   ->  Sort
         Output: c1, c2, c3, c4, c5, c6, c7, c8, tableoid
         Sort Key: t1.c3, t1.c1, t1.tableoid
         ->  Foreign Scan on public.ft1 t1
               Output: c1, c2, c3, c4, c5, c6, c7, c8, tableoid
               Remote SQL: SELECT c1, c2, c3, c4, c5, c6, c7, c8 FROM regression.t1
(8 rows)

SELECT * FROM ft1 t1 ORDER BY t1.c3, t1.c1, t1.tableoid OFFSET 100 LIMIT 10;
 c1 | c2 | c3 | c4 | c5 | c6 | c7 | c8 
----+----+----+----+----+----+----+----
(0 rows)

EXPLAIN (VERBOSE, COSTS OFF) SELECT t1 FROM ft1 t1 ORDER BY t1.c3, t1.c1 OFFSET 100 LIMIT 10;
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Limit
   Output: t1.*, c3, c1
   ->  Foreign Scan on public.ft1 t1
         Output: t1.*, c3, c1
         Remote SQL: SELECT c1, c2, c3, c4, c5, c6, c7, c8 FROM regression.t1 ORDER BY c3 ASC, c1 ASC
(5 rows)

SELECT t1 FROM ft1 t1 ORDER BY t1.c3, t1.c1 OFFSET 100 LIMIT 10;
 t1 
----
(0 rows)

SELECT * FROM ft1 WHERE false;
 c1 | c2 | c3 | c4 | c5 | c6 | c7 | c8 
----+----+----+----+----+----+----+----
(0 rows)

EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 WHERE t1.c1 = 101 AND t1.c6 = '1' AND t1.c7 >= '1';
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: c1, c2, c3, c4, c5, c6, c7, c8
   Remote SQL: SELECT c1, c2, c3, c4, c5, c6, c7, c8 FROM regression.t1 WHERE ((c7 >= '1')) AND ((c1 = 101)) AND ((c6 = '1'))
(3 rows)

SELECT COUNT(*) FROM ft1 t1;
 count 
-------
     0
(1 row)

SELECT * FROM ft1 t1 WHERE t1.c3 IN (SELECT c2 FROM ft2 t2 WHERE c1 <= 10) ORDER BY c1;
 c1 | c2 | c3 | c4 | c5 | c6 | c7 | c8 
----+----+----+----+----+----+----+----
(0 rows)

SELECT * FROM ft1 t1 WHERE t1.c3 = (SELECT MAX(c2) FROM ft2 t2) ORDER BY c1;
 c1 | c2 | c3 | c4 | c5 | c6 | c7 | c8 
----+----+----+----+----+----+----+----
(0 rows)

WITH t1 AS (SELECT * FROM ft1 WHERE c1 <= 10) SELECT t2.c1, t2.c2, t2.c2 FROM t1, ft2 t2 WHERE t1.c1 = t2.c1 ORDER BY t1.c1;
 c1 | c2 | c2 
----+----+----
(0 rows)

SELECT 'fixed', NULL FROM ft1 t1 WHERE c1 = 1;
 ?column? | ?column? 
----------+----------
(0 rows)

SET enable_hashjoin TO false;
SET enable_nestloop TO false;
EXPLAIN (VERBOSE, COSTS OFF) SELECT t1.c1, t2.c1 FROM ft2 t1 JOIN ft1 t2 ON (t1.c1 = t2.c1) OFFSET 100 LIMIT 10;
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t1.c1, t2.c1
   ->  Foreign Scan
         Output: t1.c1, t2.c1
         Relations: (ft2 t1) INNER JOIN (ft1 t2)
         Remote SQL: SELECT r1.c1, r2.c1 FROM  regression.t2 r1 ALL INNER JOIN regression.t1 r2 ON (((r1.c1 = r2.c1)))
(6 rows)

SELECT DISTINCT t1.c1, t2.c1 FROM ft2 t1 JOIN ft1 t2 ON (t1.c1 = t2.c1) order by t1.c1 LIMIT 10;
 c1 | c1 
----+----
(0 rows)

EXPLAIN (VERBOSE, COSTS OFF) SELECT t1.c1, t2.c1 FROM ft2 t1 LEFT JOIN ft1 t2 ON (t1.c1 = t2.c1) OFFSET 100 LIMIT 10;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t1.c1, t2.c1
   ->  Foreign Scan
         Output: t1.c1, t2.c1
         Relations: (ft2 t1) LEFT JOIN (ft1 t2)
         Remote SQL: SELECT r1.c1, r2.c1 FROM  regression.t2 r1 ALL LEFT JOIN regression.t1 r2 ON (((r1.c1 = r2.c1)))
(6 rows)

EXPLAIN SELECT DISTINCT t1.c1, t2.c1 FROM ft2 t1 LEFT JOIN ft1 t2 ON (t1.c1 = t2.c1) order by t1.c1 LIMIT 10;
                         QUERY PLAN                          
-------------------------------------------------------------
 Limit  (cost=1.00..-0.99 rows=1 width=8)
   ->  Unique  (cost=1.00..-0.99 rows=1 width=8)
         ->  Foreign Scan  (cost=1.00..-1.00 rows=2 width=2)
               Relations: (ft2 t1) LEFT JOIN (ft1 t2)
(4 rows)

SELECT DISTINCT t1.c1, t2.c1 FROM ft2 t1 LEFT JOIN ft1 t2 ON (t1.c1 = t2.c1) order by t1.c1 LIMIT 10;
 c1 | c1 
----+----
(0 rows)

RESET enable_hashjoin;
RESET enable_nestloop;
EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 WHERE t1.c1 = 1;         -- Var, OpExpr(b), Const
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: c1, c2, c3, c4, c5, c6, c7, c8
   Remote SQL: SELECT c1, c2, c3, c4, c5, c6, c7, c8 FROM regression.t1 WHERE ((c1 = 1))
(3 rows)

EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 WHERE t1.c1 = 100 AND t1.c2 = 0; -- BoolExpr
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: c1, c2, c3, c4, c5, c6, c7, c8
   Remote SQL: SELECT c1, c2, c3, c4, c5, c6, c7, c8 FROM regression.t1 WHERE ((c1 = 100)) AND ((c2 = 0))
(3 rows)

EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 WHERE c1 IS NULL;        -- NullTest
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: c1, c2, c3, c4, c5, c6, c7, c8
   Remote SQL: SELECT c1, c2, c3, c4, c5, c6, c7, c8 FROM regression.t1 WHERE ((c1 IS NULL))
(3 rows)

EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 WHERE c1 IS NOT NULL;    -- NullTest
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: c1, c2, c3, c4, c5, c6, c7, c8
   Remote SQL: SELECT c1, c2, c3, c4, c5, c6, c7, c8 FROM regression.t1 WHERE ((c1 IS NOT NULL))
(3 rows)

EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 WHERE round(abs(c1), 0) = 1; -- FuncExpr
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: c1, c2, c3, c4, c5, c6, c7, c8
   Remote SQL: SELECT c1, c2, c3, c4, c5, c6, c7, c8 FROM regression.t1 WHERE ((round(abs(c1), 0) = 1))
(3 rows)

EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 WHERE c1 = -c1;          -- OpExpr(l)
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: c1, c2, c3, c4, c5, c6, c7, c8
   Remote SQL: SELECT c1, c2, c3, c4, c5, c6, c7, c8 FROM regression.t1 WHERE ((c1 = (- c1)))
(3 rows)

EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 WHERE 1 = c1!;           -- OpExpr(r)
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: c1, c2, c3, c4, c5, c6, c7, c8
   Remote SQL: SELECT c1, c2, c3, c4, c5, c6, c7, c8 FROM regression.t1 WHERE ((1 = (c1 !)))
(3 rows)

EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 WHERE (c1 IS NOT NULL) IS DISTINCT FROM (c1 IS NOT NULL); -- DistinctExpr
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: c1, c2, c3, c4, c5, c6, c7, c8
   Remote SQL: SELECT c1, c2, c3, c4, c5, c6, c7, c8 FROM regression.t1 WHERE (((c1 IS NOT NULL) IS DISTINCT FROM (c1 IS NOT NULL)))
(3 rows)

EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 WHERE c1 = ANY(ARRAY[c2, 1, c1 + 0]); -- ScalarArrayOpExpr
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: c1, c2, c3, c4, c5, c6, c7, c8
   Remote SQL: SELECT c1, c2, c3, c4, c5, c6, c7, c8 FROM regression.t1 WHERE ((has(array(c2, 1, (c1 + 0)),c1)))
(3 rows)

SELECT * FROM ft1 t1 WHERE c1 = ANY(ARRAY[c2, 1, c1 + 0]) ORDER BY c1; -- ScalarArrayOpExpr
 c1 | c2 | c3 | c4 | c5 | c6 | c7 | c8 
----+----+----+----+----+----+----+----
(0 rows)

EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 WHERE c1 = (ARRAY[c1,c2,3])[1]; -- ArrayRef
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: c1, c2, c3, c4, c5, c6, c7, c8
   Remote SQL: SELECT c1, c2, c3, c4, c5, c6, c7, c8 FROM regression.t1 WHERE ((c1 = ((array(c1, c2, 3))[1])))
(3 rows)

SELECT * FROM ft1 t1 WHERE c1 = (ARRAY[c1,c2,3])[1] ORDER BY c1; -- ArrayRef
 c1 | c2 | c3 | c4 | c5 | c6 | c7 | c8 
----+----+----+----+----+----+----+----
(0 rows)

EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 WHERE c6 = E'foo''s\\bar';  -- check special chars
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: c1, c2, c3, c4, c5, c6, c7, c8
   Remote SQL: SELECT c1, c2, c3, c4, c5, c6, c7, c8 FROM regression.t1 WHERE ((c6 = E'foo''s\\bar'))
(3 rows)

EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 t1 WHERE c8 = 'foo';  -- can't be sent to remote
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Foreign Scan on public.ft1 t1
   Output: c1, c2, c3, c4, c5, c6, c7, c8
   Remote SQL: SELECT c1, c2, c3, c4, c5, c6, c7, c8 FROM regression.t1 WHERE ((c8 = 'foo'))
(3 rows)

EXPLAIN (VERBOSE, COSTS OFF) SELECT (CASE WHEN c1 < 10 THEN 1 WHEN c1 < 50 THEN 2 ELSE 3 END) a,
	sum(length(c2)) FROM ft2 GROUP BY a ORDER BY a;
                                                                                                                       QUERY PLAN                                                                                                                        
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (CASE WHEN (c1 < 10) THEN 1 WHEN (c1 < 50) THEN 2 ELSE 3 END), (sum(length(c2)))
   Sort Key: (CASE WHEN (ft2.c1 < 10) THEN 1 WHEN (ft2.c1 < 50) THEN 2 ELSE 3 END)
   ->  Foreign Scan
         Output: (CASE WHEN (c1 < 10) THEN 1 WHEN (c1 < 50) THEN 2 ELSE 3 END), (sum(length(c2)))
         Relations: Aggregate on (ft2)
         Remote SQL: SELECT CASE WHEN (c1 < 10) THEN toInt32(1) WHEN (c1 < 50) THEN toInt32(2) ELSE toInt32(3) END, sum(length(c2)) FROM regression.t2 GROUP BY (CASE WHEN (c1 < 10) THEN toInt32(1) WHEN (c1 < 50) THEN toInt32(2) ELSE toInt32(3) END)
(7 rows)

SELECT (CASE WHEN c1 < 10 THEN 1 WHEN c1 < 50 THEN 2 ELSE 3 END) a,
	sum(length(c2)) FROM ft2 GROUP BY a ORDER BY a;
 a | sum 
---+-----
(0 rows)

EXPLAIN (VERBOSE, COSTS OFF) SELECT SUM(c1) FILTER (WHERE c1 < 20) FROM ft2;
                         QUERY PLAN                          
-------------------------------------------------------------
 Foreign Scan
   Output: (sum(c1) FILTER (WHERE (c1 < 20)))
   Relations: Aggregate on (ft2)
   Remote SQL: SELECT sumIf(c1,(c1 < 20)) FROM regression.t2
(4 rows)

SELECT SUM(c1) FILTER (WHERE c1 < 20) FROM ft2;
 sum 
-----
   0
(1 row)

EXPLAIN (VERBOSE, COSTS OFF) SELECT COUNT(DISTINCT c1) FROM ft2;
                         QUERY PLAN                         
------------------------------------------------------------
 Foreign Scan
   Output: (count(DISTINCT c1))
   Relations: Aggregate on (ft2)
   Remote SQL: SELECT count(DISTINCT c1) FROM regression.t2
(4 rows)

SELECT COUNT(DISTINCT c1) FROM ft2;
 count 
-------
     0
(1 row)

/* DISTINCT with IF */
EXPLAIN (VERBOSE, COSTS OFF) SELECT COUNT(DISTINCT c1) FILTER (WHERE c1 < 20) FROM ft2;
                      QUERY PLAN                       
-------------------------------------------------------
 Aggregate
   Output: count(DISTINCT c1) FILTER (WHERE (c1 < 20))
   ->  Foreign Scan on public.ft2
         Output: c1, c2
         Remote SQL: SELECT c1 FROM regression.t2
(5 rows)

SELECT clickhousedb_raw_query('DROP DATABASE regression');
 clickhousedb_raw_query 
------------------------
 
(1 row)

DROP EXTENSION IF EXISTS clickhouse_fdw CASCADE;
NOTICE:  drop cascades to 13 other objects
DETAIL:  drop cascades to server testserver1
drop cascades to user mapping for public on server testserver1
drop cascades to server loopback
drop cascades to user mapping for user1 on server loopback
drop cascades to foreign table ft1
drop cascades to foreign table ft2
drop cascades to foreign table ft3
drop cascades to foreign table ft4
drop cascades to foreign table ft5
drop cascades to foreign table ftcopy
drop cascades to server loopback2
drop cascades to user mapping for user1 on server loopback2
drop cascades to foreign table ft6
RESET ROLE;
DROP OWNED BY user1;
DROP ROLE user1;
